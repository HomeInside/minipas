// Minipas grammar.pest 1.4.0
//
WHITESPACE = _{ (" " | "\t" | NEWLINE | comment)+ }
NEWLINE    = _{ "\n" | "\r\n" }

comment_single = { "//" ~ (!NEWLINE ~ ANY)* }
comment_braces = { "{" ~ (!"}" ~ ANY)* ~ "}" }
// comment_braces = { "{" ~ (!"}" ~ ANY)* ~ ("}" | EOI) }

comment        =  { comment_single | comment_braces }
string_literal = @{
    ("\"" ~ ("\\\"" | "\\\\" | (!"\"" ~ ANY))* ~ "\"")
  | ("'" ~ ("\\'" | "\\\\" | (!"'" ~ ANY))* ~ "'")
}

boolean_literal = { "True" | "False" }

// Tokens
keyword_var       = { "var" }
keyword_program   = { "program" }
keyword_integer   = { "integer" }
keyword_real      = { "real" }
keyword_string    = { "string" }
keyword_boolean   = { "boolean" }
keyword_writeln   = { "writeln" }
keyword_if        = { "if" }
keyword_then      = { "then" }
keyword_else      = { "else" }
keyword_const     = { "const" }
keyword_and       = { "and" }
keyword_array     = { "array" }
keyword_for       = { "for" }
keyword_while       = { "while" }
keyword_function  = { "function" }
keyword_procedure = { "procedure" }
keyword_nil       = { "nil" }
// for loop
keyword_to     = { "to" }
keyword_do       = { "do" }
keyword_downto = { "downto" }

ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
real   = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

assign_op = { ":=" }
add_op    = { "+" }
sub_op    = { "-" }
mul_op    = { "*" }
div_op    = { "/" }
mod_op    = { "%" }
cmp_op    = { ">=" | "<=" | "<>" | ">" | "<" | "=" }

semicolon = { ";" }
comma     = { "," }
colon     = { ":" }
lparen    = { "(" }
rparen    = { ")" }

//expr    = { sum }
expr = { sum ~ (cmp_op ~ sum)? }
sum     = { product ~ ((add_op | sub_op) ~ product)* }
product = { factor ~ ((mul_op | div_op| mod_op) ~ factor)* }

//
// Nueva regla para llamada a funciÃ³n/ procedimiento
func_call = { ident ~ lparen ~ (expr_list)? ~ rparen }

factor = { number | string_literal | boolean_literal | func_call | ident | keyword_nil | "(" ~ expr ~ ")" }
// AquÃ­ el `-` delante del nÃºmero se reconoce como operador unario.
// Esto permite -1 y tambiÃ©n expresiones como -(2+3).
//
// factor = { ("-"? ~ number) | string_literal | boolean_literal | func_call | ident | "(" ~ expr ~ ")" }

string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
//expr_item = { string_literal | expr }
expr_item = { expr| string_literal }

expr_list = { expr_item ~ (comma ~ expr_item)* }
expr_stmt = { expr ~ semicolon }

// ComparaciÃ³n booleana
//bool_expr = { expr ~ cmp_op ~ expr }

// Sentencias
block = { "begin" ~ stmt* ~ "end" }
stmt = { comment* ~ (if_stmt | for_stmt | while_stmt | block | assignment | expr_stmt | return_stmt) }

//if_stmt = { keyword_if ~ bool_expr ~ keyword_then ~ stmt ~ (keyword_else ~ stmt)? }
if_stmt = { keyword_if ~ expr ~ keyword_then ~ stmt ~ (keyword_else ~ stmt)? }

var_decl = { ident ~ ("," ~ ident)* ~ ":" ~ (keyword_integer | keyword_real | keyword_string | keyword_boolean) ~ ";" }

assignment = { ident ~ assign_op ~ expr ~ semicolon }

var_section = { ("var" ~ var_decl+)+ }

// procedures
proc_decl = {
  keyword_procedure ~ ident ~ lparen ~ (param_list)? ~ rparen ~ semicolon ~ var_section?
  ~ block ~ semicolon?
}

// functions
func_decl = {
    keyword_function ~ ident ~ lparen ~ (param_list)? ~ rparen ~ colon ~ (keyword_integer | keyword_real | keyword_string | keyword_boolean) ~ semicolon ~ var_section? ~ block ~ semicolon?
}

// return
return_stmt = { "return" ~ expr ~ semicolon }

// FOR LOOP
for_stmt = {
  keyword_for ~ ident ~ assign_op ~ expr
  //~ ("to" | "downto") ~ expr
  ~ (keyword_to | keyword_downto) ~ expr
  ~ keyword_do ~ stmt
}

// WHILE LOOP ðŸ‘ˆ NUEVO
while_stmt = {
  keyword_while ~ expr_boolean ~ keyword_do ~ stmt
}
//expr_boolean = { expr ~ (keyword_and ~ expr)* }
expr_boolean = _{ expr }

// param_list = { ident ~ (comma ~ ident)* ~ colon ~ (keyword_integer | keyword_real | keyword_string | keyword_boolean) ~ (semicolon ~ ident ~ (comma ~ ident)* ~ colon ~ (keyword_integer | keyword_real | keyword_string | keyword_boolean))* }
//
param_list   = { param ~ (semicolon ~ param)* }
param        = { ident ~ colon ~ type_keyword }
type_keyword = { keyword_integer | keyword_real | keyword_string | keyword_boolean }

//
program = {
    SOI ~ comment* ~ "program" ~ ident ~ semicolon ~ var_section? ~ (proc_decl | func_decl)* // ðŸ‘ˆ permitir declaraciones antes del bloque principal
  ~ block ~ "." ~ EOI
}
