// Minipas grammar.pest 0.9.0
// WHITESPACE = _{ (" " | "\t" | NEWLINE | comment | comment_multi)+ }
// WHITESPACE = _{ " " | "\t" | NEWLINE }
//
WHITESPACE = _{ (" " | "\t" | NEWLINE | comment)+ }
NEWLINE    = _{ "\n" | "\r\n" }

comment_single = { "//" ~ (!NEWLINE ~ ANY)* }
comment_braces = { "{" ~ (!"}" ~ ANY)* ~ "}" }
// comment_braces = { "{" ~ (!"}" ~ ANY)* ~ ("}" | EOI) }

comment         =  { comment_single | comment_braces }
string_literal  = @{
    ("\"" ~ ("\\\"" | "\\\\" | (!"\"" ~ ANY))* ~ "\"")
  | ("'" ~ ("\\'" | "\\\\" | (!"'" ~ ANY))* ~ "'")
}
boolean_literal =  { "true" | "false" }

// Tokens
keyword_var       = { "var" }
keyword_program   = { "program" }
keyword_integer   = { "integer" }
keyword_real      = { "real" }
keyword_string    = { "string" }
keyword_boolean   = { "boolean" }
keyword_writeln   = { "writeln" }
keyword_if        = { "if" }
keyword_then      = { "then" }
keyword_else      = { "else" }
keyword_const     = { "const" }
keyword_and       = { "and" }
keyword_array     = { "array" }
keyword_for       = { "for" }
keyword_function  = { "function" }
keyword_procedure = { "procedure" }
keyword_nil       = { "nil" }

ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
real   = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

assign_op = { ":=" }
add_op    = { "+" }
sub_op    = { "-" }
mul_op    = { "*" }
div_op    = { "/" }
cmp_op    = { ">=" | "<=" | "<>" | ">" | "<" | "=" }

semicolon = { ";" }
comma     = { "," }
colon     = { ":" }
lparen    = { "(" }
rparen    = { ")" }

// Expresiones
// expr = { term ~ ((add_op | sub_op | mul_op | div_op) ~ term)* }
// term = _{ factor }
// factor = _{ number | ident | lparen ~ expr ~ rparen }
//
expr    = { sum }
sum     = { product ~ ((add_op | sub_op) ~ product)* }
product = { factor ~ ((mul_op | div_op) ~ factor)* }

// Nueva regla para llamada a función/ procedimiento
func_call = { ident ~ lparen ~ (expr_list)? ~ rparen }

factor = { number | string_literal | boolean_literal | func_call | ident | "(" ~ expr ~ ")" }
// Aquí el `-` delante del número se reconoce como operador unario.
// Esto permite -1 y también expresiones como -(2+3).
//
// factor = { ("-"? ~ number) | string_literal | boolean_literal | func_call | ident | "(" ~ expr ~ ")" }

string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

expr_item = { string_literal | expr }

expr_list = { expr_item ~ (comma ~ expr_item)* }
expr_stmt = { expr ~ semicolon }

// Comparación booleana
bool_expr = { expr ~ cmp_op ~ expr }

// Sentencias
block = { "begin" ~ stmt* ~ "end" }
stmt  = { comment* ~ (if_stmt | block | assignment | expr_stmt) }

if_stmt = { keyword_if ~ bool_expr ~ keyword_then ~ stmt ~ (keyword_else ~ stmt)? }

// var_decl = { keyword_var ~ ident ~ (comma ~ ident)* ~ colon ~ (keyword_integer | keyword_real | keyword_string | keyword_boolean) ~ semicolon }
var_decl = { ident ~ ("," ~ ident)* ~ ":" ~ (keyword_integer | keyword_real | keyword_string | keyword_boolean) ~ ";" }

assignment = { ident ~ assign_op ~ expr ~ semicolon }

// var_section = { var_decl+ }
var_section = { ("var" ~ var_decl+)+ }

program = { SOI ~ comment* ~ "program" ~ ident ~ semicolon ~ var_section? ~ block ~ "." ~ EOI }
